#!/bin/bash

# Simplified CVE Processor Deployment Script
# Deploys Azure Functions instead of Container Apps Environment

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    print_status "Checking prerequisites..."
    
    if ! command -v terraform &> /dev/null; then
        print_error "Terraform is not installed."
        exit 1
    fi
    
    if ! command -v az &> /dev/null; then
        print_error "Azure CLI is not installed."
        exit 1
    fi
    
    if ! command -v func &> /dev/null; then
        print_warning "Azure Functions Core Tools not found. Installing..."
        npm install -g azure-functions-core-tools@4 --unsafe-perm true
    fi
    
    if ! az account show &> /dev/null; then
        print_error "Not logged into Azure. Please run 'az login' first."
        exit 1
    fi
    
    print_status "Prerequisites check completed."
}

# Deploy infrastructure using simplified Terraform
deploy_infrastructure() {
    print_status "Deploying simplified infrastructure with Terraform..."
    
    if [ ! -f "terraform.tfvars" ]; then
        print_error "terraform.tfvars not found. Please create it with your API keys."
        exit 1
    fi
    
    if grep -q "REPLACE_WITH_YOUR_" terraform.tfvars; then
        print_error "terraform.tfvars contains placeholder values. Please update with real values."
        exit 1
    fi
    
    # Infrastructure is already simplified
    
    terraform init
    terraform plan -out=tfplan
    terraform apply tfplan
    rm tfplan
    
    print_status "Infrastructure deployment completed."
}

# Add current external IP to Azure SQL firewall
allow_current_ip_sql() {
    print_status "Allowing current external IP for Azure SQL access..."

    RESOURCE_GROUP=$(terraform output -raw resource_group_name)
    SQL_SERVER_FQDN=$(terraform output -raw sql_server_fqdn)

    # Derive server short name from FQDN (strip .database.windows.net)
    SQL_SERVER_NAME=${SQL_SERVER_FQDN%%.database.windows.net}

    # Detect public IP (try two providers)
    PUBLIC_IP=$(curl -s https://ifconfig.me || true)
    if [[ -z "$PUBLIC_IP" ]]; then
        PUBLIC_IP=$(curl -s https://api.ipify.org || true)
    fi

    if [[ -z "$PUBLIC_IP" ]]; then
        print_warning "Could not determine public IP automatically. Skipping firewall rule creation."
        return
    fi

    print_status "Detected public IP: $PUBLIC_IP"

    RULE_NAME="AllowCurrentIP"

    # Create or update the firewall rule for this IP
    if az sql server firewall-rule show \
        --resource-group "$RESOURCE_GROUP" \
        --server "$SQL_SERVER_NAME" \
        --name "$RULE_NAME" >/dev/null 2>&1; then
        az sql server firewall-rule update \
            --resource-group "$RESOURCE_GROUP" \
            --server "$SQL_SERVER_NAME" \
            --name "$RULE_NAME" \
            --start-ip-address "$PUBLIC_IP" \
            --end-ip-address "$PUBLIC_IP" \
            --only-show-errors >/dev/null
        print_status "Updated SQL firewall rule '$RULE_NAME' to $PUBLIC_IP"
    else
        az sql server firewall-rule create \
            --resource-group "$RESOURCE_GROUP" \
            --server "$SQL_SERVER_NAME" \
            --name "$RULE_NAME" \
            --start-ip-address "$PUBLIC_IP" \
            --end-ip-address "$PUBLIC_IP" \
            --only-show-errors >/dev/null
        print_status "Created SQL firewall rule '$RULE_NAME' for $PUBLIC_IP"
    fi
}

# Deploy database schema
deploy_database() {
    print_status "Deploying simplified database schema..."
    
    SERVER_NAME=$(terraform output -raw sql_server_fqdn)
    DATABASE_NAME=$(terraform output -raw database_name)
    
    print_status "Database: $SERVER_NAME/$DATABASE_NAME"
    
    if command -v sqlcmd &> /dev/null; then
        print_status "Using sqlcmd to deploy schema..."
        echo "Enter SQL admin password:"
        read -s SQL_PASSWORD
        
        sqlcmd -S "$SERVER_NAME" -d "$DATABASE_NAME" -U "$(terraform output -raw sql_admin_username)" -P "$SQL_PASSWORD" -i database/schema.sql
        print_status "Database schema deployed successfully."
    else
        print_warning "sqlcmd not found. Please run database/schema.sql manually."
        print_warning "Connect to: $SERVER_NAME"
        print_warning "Database: $DATABASE_NAME"
    fi
}

# Deploy Azure Functions
deploy_functions() {
    print_status "Deploying Azure Functions..."
    
    RESOURCE_GROUP=$(terraform output -raw resource_group_name)
    NVD_FUNCTION_NAME=$(terraform output -raw nvd_function_name)
    SOC_FUNCTION_NAME=$(terraform output -raw soc_function_name)
    
    # Deploy NVD Ingestion Function
    print_status "Deploying NVD Ingestion Function..."
    cd functions/nvd-ingestion
    func azure functionapp publish $NVD_FUNCTION_NAME --python
    cd ../..
    
    # Deploy SOC Processor Function
    print_status "Deploying SOC Processor Function..."
    cd functions/soc-processor
    func azure functionapp publish $SOC_FUNCTION_NAME --python
    cd ../..
    
    print_status "Azure Functions deployed successfully."
}

# Deploy web application
deploy_webapp() {
    print_status "Deploying web application..."
    
    RESOURCE_GROUP=$(terraform output -raw resource_group_name)
    WEBAPP_NAME=$(terraform output -raw webapp_name)
    
    print_status "Creating deployment package..."
    cd webapp
    zip -r ../webapp.zip . -x "*.pyc" "__pycache__/*"
    cd ..
    
    print_status "Deploying to Azure App Service..."
    az webapp deployment source config-zip \
        --resource-group "$RESOURCE_GROUP" \
        --name "$WEBAPP_NAME" \
        --src webapp.zip
    
    rm webapp.zip
    print_status "Web application deployed successfully."
}

# Test deployment
test_deployment() {
    print_status "Testing deployment..."
    
    WEBAPP_URL=$(terraform output -raw webapp_url)
    
    print_status "Testing web application health..."
    if curl -f "$WEBAPP_URL/health" >/dev/null 2>&1; then
        print_status "Web application is healthy."
    else
        print_warning "Web application may not be ready yet. Check logs in Azure portal."
    fi
    
    print_status "Testing manual function execution (NVDIngestion)..."
    RESOURCE_GROUP=$(terraform output -raw resource_group_name)
    NVD_FUNCTION_NAME=$(terraform output -raw nvd_function_name)

    # Ensure function app is started
    az functionapp start --name "$NVD_FUNCTION_NAME" --resource-group "$RESOURCE_GROUP" >/dev/null 2>&1 || true

    # Get master (host) key for admin API invoke
    MASTER_KEY=$(az functionapp keys list \
        --name "$NVD_FUNCTION_NAME" \
        --resource-group "$RESOURCE_GROUP" \
        --query masterKey -o tsv 2>/dev/null || true)

    if [[ -z "$MASTER_KEY" ]]; then
        print_warning "Could not retrieve Function App master key; skipping manual invoke."
    else
        # Invoke the timer function via admin endpoint
        INVOKE_URL="https://$NVD_FUNCTION_NAME.azurewebsites.net/admin/functions/NVDIngestion"
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "$INVOKE_URL" \
            -H "x-functions-key: $MASTER_KEY" \
            -H "Content-Type: application/json" \
            -d '{"input":"manual"}')

        if [[ "$HTTP_CODE" == "200" || "$HTTP_CODE" == "202" ]]; then
            print_status "Triggered NVDIngestion function successfully (HTTP $HTTP_CODE)."
        else
            print_warning "Admin invoke returned HTTP $HTTP_CODE - check Function logs if needed."
        fi
    fi
}

# Main deployment
main() {
    echo "========================================="
    echo "Simplified CVE Processor Deployment"
    echo "Using Azure Functions instead of Container Apps"
    echo "========================================="
    echo
    
    check_prerequisites
    echo
    
    deploy_infrastructure
    echo

    # Ensure local access to SQL for schema deployment
    allow_current_ip_sql
    echo

    deploy_database
    echo
    
    deploy_functions
    echo
    
    deploy_webapp
    echo
    
    test_deployment
    echo
    
    print_status "Deployment completed successfully!"
    echo
    
    echo "========================================="
    echo "Deployment Summary"
    echo "========================================="
    echo "Resource Group: $(terraform output -raw resource_group_name)"
    echo "SQL Server: $(terraform output -raw sql_server_fqdn)"
    echo "Database: $(terraform output -raw database_name)"
    echo "Web App: $(terraform output -raw webapp_url)"
    echo "NVD Function: $(terraform output -raw nvd_function_name)"
    echo "SOC Function: $(terraform output -raw soc_function_name)"
    echo
    
    print_status "The system is now fully automated:"
    echo "• NVD ingestion runs every 2 hours automatically"
    echo "• SOC analysis processes queued CVEs automatically"
    echo "• Visit $(terraform output -raw webapp_url) to see results"
    echo
    
    print_status "Monitor function logs:"
    echo "az functionapp logs tail --name $(terraform output -raw nvd_function_name) --resource-group $(terraform output -raw resource_group_name)"
    echo "az functionapp logs tail --name $(terraform output -raw soc_function_name) --resource-group $(terraform output -raw resource_group_name)"
}

main "$@"
